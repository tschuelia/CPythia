# Pythia C Library
This is the Pythia difficulty prediction module for [Coraxlib](https://codeberg.org/Exelixis-Lab/coraxlib). 
Since this module relies on Coraxlib types and Coraxlib cmake scopes this module is only intended for use in combination with Coraxlib.

The module provides functionality for computing and collecting the features for a given multiple sequence alignment (MSA) that are required to predict the difficulty, as well as a function for predicting the difficulty. 
The prediction code in `./difficulty` is an autogenerated export of a trained scikit-learn Random Decision Forest (exported using the [Treelite model compiler](https://github.com/dmlc/treelite)). 

### Python Library
The same functionality is also available as lightweight, stand-along Python library [here](https://github.com/tschuelia/PyPythia).  If you are only interested in the difficulty of your MSA, we recommend using the Python version of Pythia. If you want to incorporate the difficulty prediction in a phylogenetic tool, we recommend using this faster C library.

### Usage example
```c++
#include <iostream>
#include <vector>
#include <map>
#include <tuple>
#include <math.h>
#include "corax/corax.h"
#include "difficulty.h"


std::vector<corax_split_t *> get_pars_splits(corax_msa_t *msa, int n_trees)
{
  /**
   * Infers n_trees parsimony trees for the given MSA using Coraxlib, creates and returns the splits.
   */
  std::vector<corax_utree_t *> pars_trees(n_trees);
  std::vector<corax_split_t *> splits(n_trees);

  std::map<std::string, unsigned int> labelToId;

  unsigned int score;
  int n_taxa = msa->count;

  for (int i = 0; i < n_trees; ++i)
  {
    pars_trees[i] = corax_utree_create_parsimony(n_taxa,
                                                 msa->length,
                                                 msa->label,
                                                 msa->sequence,
                                                 NULL, /* site weights */
                                                 corax_map_nt,
                                                 4,
                                                 0,
                                                 i, /* seed */
                                                 &score);
  }

  for (int i = 0; i < n_taxa; ++i)
  {
    labelToId.insert({std::string(pars_trees[0]->nodes[i]->label), i});
  }

  for (corax_utree_t * tree: pars_trees)
  {
    for (int i = 0; i < n_taxa; ++i)
    {
      auto leaf        = tree->nodes[i];
      auto id          = labelToId.at(std::string(leaf->label));
      leaf->node_index = leaf->clv_index = id;
    }
  }

  for (int i = 0; i < n_trees; ++i)
  {
    splits[i] = corax_utree_split_create(pars_trees[i]->vroot, n_taxa, nullptr);
  }

  for (int i = 0; i < n_trees; ++i)
  {
    corax_utree_destroy(pars_trees[i], NULL);
  }

  return splits;
}


std::tuple<int, double> get_num_unique_and_rel_rfdist(std::vector<corax_split_t *> splits, int n_taxa)
{
  /**
   * Computes the average relative RF distance and the number of unique topologies for the given splits.
   */
  int num_trees = splits.size();
  int num_unique = 1;
  double avg_rrf = 0.0;
  double max_rf = (double)2 * (n_taxa - 3);
  size_t num_pairs =  0;

  for (int i = 0; i < num_trees - 1; ++i)
  {
    bool uniq = true;
    for (int j = i + 1; j < num_trees; ++j)
    {
      double rf = corax_utree_split_rf_distance(splits[i], splits[j], n_taxa);

      avg_rrf += ((double)rf) / max_rf;
      num_pairs++;

      uniq &= (rf > 0);
    }
    if (uniq)
      num_unique++;
  }

  avg_rrf /= num_pairs;

  return {num_unique, avg_rrf};
}


int main(int argc, char *argv[])
{
  const char *filename = "path/to/msa.phy";
  /*
   * make sure to update this function call based on your MSA:
   * - for MSAs in phylip format use corax_phylip_load and set the interleaved flag accordingly
   * - for MSAs in fasta format use corax_fasta_load
   */
  corax_msa_t *msa = corax_phylip_load(filename, CORAX_FALSE);

  size_t _num_trees = 100;
  int n_taxa = msa->count;

  std::vector<corax_split_t *> splits = get_pars_splits(msa, _num_trees);

  int num_unique;
  double avg_rrf;
  std::tie(num_unique, avg_rrf) = get_num_unique_and_rel_rfdist(splits, n_taxa);

  corax_msa_features * features = corax_msa_compute_features(msa, 4, corax_map_nt);

  double out_pred = corax_msa_predict_difficulty(features, avg_rrf, num_unique / _num_trees);
  out_pred = round(out_pred * 100.0) / 100.0;

  std::cout << "The predicted difficulty for MSA " << filename << " is: " << out_pred << "\n";

  corax_msa_destroy(msa);
  free(features);

  for (auto s : splits) corax_utree_split_destroy(s);
}
```

## Exporting PyPythia to CPythia
The following instructions explain how you can export the latest (Pypythia)[https://github.com/tschuelia/PyPythia] predictor to C.
PyPythia predictors are LightGBM Boosters and you can use the (tl2cgen)[https://tl2cgen.readthedocs.io] library to generate a collection of C files that contain all the decisions of all trees in the predictor as plain if-statements. I recommend using a Jupyter Notebook for running the following code.

1. Install the required packages (see the Note below if you have a MacBook with an ARM chip):
   - lightgbm
   - tl2cgen
   - treelite
   - notebook # when using Jupyter Notebooks as recommended

2. Import the required libraries
```python
import lightgbm as lgb
import tl2cgen
import treelite
import pickle   # if your predictor is pickled
```

3. Load the model as python object
```python
# if the predictor is pickled
model_file = "path/to/model"

model = pickle.load(open(model_file, "rb"))

# if the predictor is a LightGBM .txt model export
model = lgb.Booster(model_file=model_file)
```

4. Export the model using treelite & tl2cgen
```python
params = {"parallel_comp": 16}  # this will split the resulting C export into 16 files for parallel compilation

treelite_model = treelite.frontend.from_lightgbm(model)
library_name = "CPythia"

tl2cgen.export_srcpkg(
    treelite_model,
    toolchain="gcc",
    pkgpath="CPythia.zip",
    libname=library_name,
    params=params,
    verbose=False
)
```
This will generate a `.zip` file in your current working directory named `CPythia.zip`.

5. Open the `.zip` file and delete the `Makefile` and `recipe.json`. 
6. Rename the `header.c` and `main.c` files to `prediction.c` and `prediction.h`. Make sure to also rename the respective include statements in the `tu*.c` files!
7. Replace all files in the `difficulty` directory of this repo with the created files.


 **Note for MacBooks with ARM Chips**
Until the tl2cgen feedstock merges the ARM-OSX migration, you need to install the OSX-64 version of **all** packages to be able to run these instructions.
To do so, you need to use `micromamba` and create a new environment with the `platform` flag:

`micromamba env create -n foo --platform osx-64`

Afterwards you can simply install everything as usual with `micromamba install ...`


## Publication
The paper explaining the details of Pythia is published in MBE:
Haag, J., HÃ¶hler, D., Bettisworth, B., & Stamatakis, A. (2022). **From Easy to Hopeless - Predicting the Difficulty of Phylogenetic Analyses.** *Molecular Biology and Evolution*, 39(12). [https://doi.org/10.1093/molbev/msac254](https://doi.org/10.1093/molbev/msac254)

